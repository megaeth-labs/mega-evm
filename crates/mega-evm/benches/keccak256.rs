//! Benchmarks for the KECCAK256 opcode.
//!
//! This benchmark suite measures the performance of the KECCAK256 opcode
//! with varying input sizes, comparing performance across different
//! EVM specifications (`EQUIVALENCE` vs `MINI_REX`).

#![allow(missing_docs)]

use alloy_primitives::{address, Address, Bytes, U256};
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use mega_evm::{
    test_utils::{opcode_gen::BytecodeBuilder, MemoryDatabase},
    MegaContext, MegaEvm, MegaSpecId, MegaTransaction, DefaultExternalEnvs,
};
use revm::{context::tx::TxEnvBuilder, ExecuteEvm};

const CALLER: Address = address!("0000000000000000000000000000000000100000");
const KECCAK_CONTRACT: Address = address!("0000000000000000000000000000000000100002");

// EVM opcodes
const KECCAK256: u8 = 0x20;
const POP: u8 = 0x50;

/// Generate bytecode that benchmarks KECCAK256 opcode with specified data size.
/// The bytecode fills memory with data, then calls KECCAK256 multiple times.
///
/// Generated bytecode:
/// 1. Fill memory with data using MSTORE (32-byte chunks)
/// 2. Loop `iterations` times calling KECCAK256 on the data
fn generate_keccak256_bytecode(data_size: usize, iterations: usize) -> Bytes {
    let mut builder = BytecodeBuilder::default();

    // Fill memory with data
    let data = vec![0xFF; data_size];
    builder = builder.mstore(0, data);

    // Call KECCAK256 multiple times
    for _ in 0..iterations {
        builder = builder.push_number(data_size as u64); // size
        builder = builder.push_number(0_u64); // offset
        builder = builder.append(KECCAK256);
        builder = builder.append(POP); // remove hash result from stack
    }

    builder.build()
}

/// Benchmark KECCAK256 opcode with varying data sizes.
fn bench_keccak256_opcode(c: &mut Criterion) {
    const ITERATIONS: usize = 1;

    // Test different data sizes
    let test_cases = [("32B", 32), ("256B", 256), ("1KB", 1024), ("4KB", 4096)];

    for (size_name, data_size) in test_cases {
        let mut group = c.benchmark_group(format!("keccak256_{}", size_name));
        let bytecode = generate_keccak256_bytecode(data_size, ITERATIONS);

        for (spec_name, spec) in
            [("equivalence", MegaSpecId::EQUIVALENCE), ("mini_rex", MegaSpecId::MINI_REX)]
        {
            group.bench_function(spec_name, |b| {
                b.iter(|| {
                    let db = MemoryDatabase::default()
                        .account_code(KECCAK_CONTRACT, bytecode.clone())
                        .account_balance(CALLER, U256::from(10).pow(U256::from(18))); // 1 ETH for gas

                    let mut context =
                        MegaContext::new(black_box(db), black_box(spec), DefaultExternalEnvs::default());
                    context.modify_chain(|chain| {
                        chain.operator_fee_scalar = Some(U256::from(0));
                        chain.operator_fee_constant = Some(U256::from(0));
                    });
                    let mut evm = MegaEvm::new(context);

                    let tx = TxEnvBuilder::new().caller(CALLER).call(KECCAK_CONTRACT).build_fill();
                    let mut mega_tx = MegaTransaction::new(tx);
                    mega_tx.enveloped_tx = Some(Bytes::new());

                    let result = evm.transact(mega_tx).expect("transaction should succeed");
                    black_box(result)
                })
            });
        }

        group.finish();
    }
}

criterion_group!(benches, bench_keccak256_opcode);
criterion_main!(benches);
